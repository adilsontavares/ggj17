// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/EyeXPluginPrivatePCH.h"
#include "GeneratedCppIncludes.h"
#include "TobiiEyeX.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCode1TobiiEyeX() {}
FName TOBIIEYEX_GotGazeFocusBP = FName(TEXT("GotGazeFocusBP"));
FName TOBIIEYEX_LostGazeFocusBP = FName(TEXT("LostGazeFocusBP"));
	void AEyeXActorBase::GotGazeFocusBP()
	{
		ProcessEvent(FindFunctionChecked(TOBIIEYEX_GotGazeFocusBP),NULL);
	}
	void AEyeXActorBase::LostGazeFocusBP()
	{
		ProcessEvent(FindFunctionChecked(TOBIIEYEX_LostGazeFocusBP),NULL);
	}
	void AEyeXActorBase::StaticRegisterNativesAEyeXActorBase()
	{
		FNativeFunctionRegistrar::RegisterFunction(AEyeXActorBase::StaticClass(), "HasGazeFocus",(Native)&AEyeXActorBase::execHasGazeFocus);
	}
	IMPLEMENT_CLASS(AEyeXActorBase, 2619493941);
static class UEnum* EEyeXEmulationMode_StaticEnum()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode();
		Singleton = GetStaticEnum(Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EEyeXEmulationMode"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEyeXEmulationMode(EEyeXEmulationMode_StaticEnum, TEXT("/Script/TobiiEyeX"), TEXT("EEyeXEmulationMode"), false, nullptr, nullptr);
static class UEnum* EEyeXUserPresence_StaticEnum()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence();
		Singleton = GetStaticEnum(Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EEyeXUserPresence"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEyeXUserPresence(EEyeXUserPresence_StaticEnum, TEXT("/Script/TobiiEyeX"), TEXT("EEyeXUserPresence"), false, nullptr, nullptr);
static class UEnum* EEyeXDeviceStatus_StaticEnum()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus();
		Singleton = GetStaticEnum(Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EEyeXDeviceStatus"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEyeXDeviceStatus(EEyeXDeviceStatus_StaticEnum, TEXT("/Script/TobiiEyeX"), TEXT("EEyeXDeviceStatus"), false, nullptr, nullptr);
static class UEnum* EEyeXFixationDataMode_StaticEnum()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode();
		Singleton = GetStaticEnum(Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EEyeXFixationDataMode"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEyeXFixationDataMode(EEyeXFixationDataMode_StaticEnum, TEXT("/Script/TobiiEyeX"), TEXT("EEyeXFixationDataMode"), false, nullptr, nullptr);
static class UEnum* EEyeXGazePointDataMode_StaticEnum()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode();
		Singleton = GetStaticEnum(Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EEyeXGazePointDataMode"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEyeXGazePointDataMode(EEyeXGazePointDataMode_StaticEnum, TEXT("/Script/TobiiEyeX"), TEXT("EEyeXGazePointDataMode"), false, nullptr, nullptr);
class UScriptStruct* FEyeXScreenBounds::StaticStruct()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXScreenBounds();
		extern TOBIIEYEX_API uint32 Get_Z_Construct_UScriptStruct_FEyeXScreenBounds_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FEyeXScreenBounds, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EyeXScreenBounds"), sizeof(FEyeXScreenBounds), Get_Z_Construct_UScriptStruct_FEyeXScreenBounds_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FEyeXScreenBounds(FEyeXScreenBounds::StaticStruct, TEXT("/Script/TobiiEyeX"), TEXT("EyeXScreenBounds"), false, nullptr, nullptr);
static struct FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXScreenBounds
{
	FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXScreenBounds()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("EyeXScreenBounds")),new UScriptStruct::TCppStructOps<FEyeXScreenBounds>);
	}
} ScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXScreenBounds;
class UScriptStruct* FEyeXEyePosition::StaticStruct()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXEyePosition();
		extern TOBIIEYEX_API uint32 Get_Z_Construct_UScriptStruct_FEyeXEyePosition_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FEyeXEyePosition, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EyeXEyePosition"), sizeof(FEyeXEyePosition), Get_Z_Construct_UScriptStruct_FEyeXEyePosition_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FEyeXEyePosition(FEyeXEyePosition::StaticStruct, TEXT("/Script/TobiiEyeX"), TEXT("EyeXEyePosition"), false, nullptr, nullptr);
static struct FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXEyePosition
{
	FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXEyePosition()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("EyeXEyePosition")),new UScriptStruct::TCppStructOps<FEyeXEyePosition>);
	}
} ScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXEyePosition;
class UScriptStruct* FEyeXFixationDataPoint::StaticStruct()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXFixationDataPoint();
		extern TOBIIEYEX_API uint32 Get_Z_Construct_UScriptStruct_FEyeXFixationDataPoint_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FEyeXFixationDataPoint, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EyeXFixationDataPoint"), sizeof(FEyeXFixationDataPoint), Get_Z_Construct_UScriptStruct_FEyeXFixationDataPoint_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FEyeXFixationDataPoint(FEyeXFixationDataPoint::StaticStruct, TEXT("/Script/TobiiEyeX"), TEXT("EyeXFixationDataPoint"), false, nullptr, nullptr);
static struct FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXFixationDataPoint
{
	FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXFixationDataPoint()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("EyeXFixationDataPoint")),new UScriptStruct::TCppStructOps<FEyeXFixationDataPoint>);
	}
} ScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXFixationDataPoint;
class UScriptStruct* FEyeXGazePoint::StaticStruct()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXGazePoint();
		extern TOBIIEYEX_API uint32 Get_Z_Construct_UScriptStruct_FEyeXGazePoint_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FEyeXGazePoint, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EyeXGazePoint"), sizeof(FEyeXGazePoint), Get_Z_Construct_UScriptStruct_FEyeXGazePoint_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FEyeXGazePoint(FEyeXGazePoint::StaticStruct, TEXT("/Script/TobiiEyeX"), TEXT("EyeXGazePoint"), false, nullptr, nullptr);
static struct FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXGazePoint
{
	FScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXGazePoint()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("EyeXGazePoint")),new UScriptStruct::TCppStructOps<FEyeXGazePoint>);
	}
} ScriptStruct_TobiiEyeX_StaticRegisterNativesFEyeXGazePoint;
	void UEyeXBlueprintLibrary::StaticRegisterNativesUEyeXBlueprintLibrary()
	{
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "Get3DGazePoint",(Native)&UEyeXBlueprintLibrary::execGet3DGazePoint);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetDisplaySize",(Native)&UEyeXBlueprintLibrary::execGetDisplaySize);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetEmulationMode",(Native)&UEyeXBlueprintLibrary::execGetEmulationMode);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetEyePosition",(Native)&UEyeXBlueprintLibrary::execGetEyePosition);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetEyeTrackingDeviceStatus",(Native)&UEyeXBlueprintLibrary::execGetEyeTrackingDeviceStatus);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetGazePoint",(Native)&UEyeXBlueprintLibrary::execGetGazePoint);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetHeadRotation",(Native)&UEyeXBlueprintLibrary::execGetHeadRotation);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetLastFixation",(Native)&UEyeXBlueprintLibrary::execGetLastFixation);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetOngoingFixation",(Native)&UEyeXBlueprintLibrary::execGetOngoingFixation);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetScreenBounds",(Native)&UEyeXBlueprintLibrary::execGetScreenBounds);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "GetUserPresence",(Native)&UEyeXBlueprintLibrary::execGetUserPresence);
		FNativeFunctionRegistrar::RegisterFunction(UEyeXBlueprintLibrary::StaticClass(), "SetEmulationMode",(Native)&UEyeXBlueprintLibrary::execSetEmulationMode);
	}
	IMPLEMENT_CLASS(UEyeXBlueprintLibrary, 2720277644);
static class UEnum* EEyeXDetectionMode_StaticEnum()
{
	extern TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode();
		Singleton = GetStaticEnum(Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode, Z_Construct_UPackage__Script_TobiiEyeX(), TEXT("EEyeXDetectionMode"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EEyeXDetectionMode(EEyeXDetectionMode_StaticEnum, TEXT("/Script/TobiiEyeX"), TEXT("EEyeXDetectionMode"), false, nullptr, nullptr);
	void AEyeXPlayerController::StaticRegisterNativesAEyeXPlayerController()
	{
		FNativeFunctionRegistrar::RegisterFunction(AEyeXPlayerController::StaticClass(), "GetGazeHitResult",(Native)&AEyeXPlayerController::execGetGazeHitResult);
	}
	IMPLEMENT_CLASS(AEyeXPlayerController, 2239058477);
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintFunctionLibrary();
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionChannel();

	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_AEyeXActorBase_GotGazeFocusBP();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_AEyeXActorBase_HasGazeFocus();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_AEyeXActorBase_LostGazeFocusBP();
	TOBIIEYEX_API class UClass* Z_Construct_UClass_AEyeXActorBase_NoRegister();
	TOBIIEYEX_API class UClass* Z_Construct_UClass_AEyeXActorBase();
	TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode();
	TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence();
	TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus();
	TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode();
	TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode();
	TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXScreenBounds();
	TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXEyePosition();
	TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXFixationDataPoint();
	TOBIIEYEX_API class UScriptStruct* Z_Construct_UScriptStruct_FEyeXGazePoint();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_Get3DGazePoint();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetDisplaySize();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEmulationMode();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyePosition();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyeTrackingDeviceStatus();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetGazePoint();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetHeadRotation();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetLastFixation();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetOngoingFixation();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetScreenBounds();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetUserPresence();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_SetEmulationMode();
	TOBIIEYEX_API class UClass* Z_Construct_UClass_UEyeXBlueprintLibrary_NoRegister();
	TOBIIEYEX_API class UClass* Z_Construct_UClass_UEyeXBlueprintLibrary();
	TOBIIEYEX_API class UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode();
	TOBIIEYEX_API class UFunction* Z_Construct_UFunction_AEyeXPlayerController_GetGazeHitResult();
	TOBIIEYEX_API class UClass* Z_Construct_UClass_AEyeXPlayerController_NoRegister();
	TOBIIEYEX_API class UClass* Z_Construct_UClass_AEyeXPlayerController();
	TOBIIEYEX_API class UPackage* Z_Construct_UPackage__Script_TobiiEyeX();
	UFunction* Z_Construct_UFunction_AEyeXActorBase_GotGazeFocusBP()
	{
		UObject* Outer=Z_Construct_UClass_AEyeXActorBase();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GotGazeFocusBP"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Fires when this actor has received the focus of the users gaze. Requires no super call when overriding since it doesn't\ndo anything."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AEyeXActorBase_HasGazeFocus()
	{
		struct EyeXActorBase_eventHasGazeFocus_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AEyeXActorBase();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasGazeFocus"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(EyeXActorBase_eventHasGazeFocus_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, EyeXActorBase_eventHasGazeFocus_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, EyeXActorBase_eventHasGazeFocus_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, EyeXActorBase_eventHasGazeFocus_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check to see if this actor is focused by the users gaze.\n@return true if this actor is focused by the users gaze."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AEyeXActorBase_LostGazeFocusBP()
	{
		UObject* Outer=Z_Construct_UClass_AEyeXActorBase();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LostGazeFocusBP"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Fires when this actor has lost the focus of the users gaze. Requires no super call when overriding since it doesn't\ndo anything."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AEyeXActorBase_NoRegister()
	{
		return AEyeXActorBase::StaticClass();
	}
	UClass* Z_Construct_UClass_AEyeXActorBase()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_TobiiEyeX();
			OuterClass = AEyeXActorBase::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AEyeXActorBase_GotGazeFocusBP());
				OuterClass->LinkChild(Z_Construct_UFunction_AEyeXActorBase_HasGazeFocus());
				OuterClass->LinkChild(Z_Construct_UFunction_AEyeXActorBase_LostGazeFocusBP());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DwellTimeDeactivate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DwellTimeDeactivate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DwellTimeDeactivate, AEyeXActorBase), 0x0010000000000005);
				UProperty* NewProp_DwellTimeActivate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DwellTimeActivate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DwellTimeActivate, AEyeXActorBase), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVisualizeDistance, AEyeXActorBase, bool);
				UProperty* NewProp_bVisualizeDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bVisualizeDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVisualizeDistance, AEyeXActorBase), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bVisualizeDistance, AEyeXActorBase), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreHeightInDistanceCalculation, AEyeXActorBase, bool);
				UProperty* NewProp_bIgnoreHeightInDistanceCalculation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIgnoreHeightInDistanceCalculation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreHeightInDistanceCalculation, AEyeXActorBase), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIgnoreHeightInDistanceCalculation, AEyeXActorBase), sizeof(bool), true);
				UProperty* NewProp_MaxDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxDistance, AEyeXActorBase), 0x0010000000000005);
				UProperty* NewProp_MinDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinDistance, AEyeXActorBase), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AEyeXActorBase_GotGazeFocusBP(), "GotGazeFocusBP"); // 2121983402
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AEyeXActorBase_HasGazeFocus(), "HasGazeFocus"); // 2588242747
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AEyeXActorBase_LostGazeFocusBP(), "LostGazeFocusBP"); // 894073588
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("EyeXActorBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The EyeXActorBase class is a base class for actors which can be interacted with using eye-gaze.\nThe GotGazeFocus event is triggered when the user is looking at the object\nand LostGazeFocus is triggered when the user stops looking. Additionally\nthe status of the actor can be checked using the HasGazeFocus function.\n\nThe events can be overriden when using C++ or called in Blueprint. In order\nto use this class the scene needs to contain an EyeXPlayerController which\ndetermines which actor has the attention of the user."));
				MetaData->SetValue(NewProp_DwellTimeDeactivate, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_DwellTimeDeactivate, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(NewProp_DwellTimeDeactivate, TEXT("ToolTip"), TEXT("The time it takes until this actors behavior is deactivated once the gaze has stopped falling upon it. Using some dwell time\n      can be required in order to ignore false positives."));
				MetaData->SetValue(NewProp_DwellTimeActivate, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_DwellTimeActivate, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(NewProp_DwellTimeActivate, TEXT("ToolTip"), TEXT("The time it takes until this actors behavior is activated once the gaze has fallen upon it. Using some dwell time\n      can be required in order to ignore false positives."));
				MetaData->SetValue(NewProp_bVisualizeDistance, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_bVisualizeDistance, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(NewProp_bVisualizeDistance, TEXT("ToolTip"), TEXT("Set to true to visualize the minimum and maximum distance. Disabled for shipping builds."));
				MetaData->SetValue(NewProp_bIgnoreHeightInDistanceCalculation, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_bIgnoreHeightInDistanceCalculation, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(NewProp_bIgnoreHeightInDistanceCalculation, TEXT("ToolTip"), TEXT("Set to true to ignore height when calculating distances."));
				MetaData->SetValue(NewProp_MaxDistance, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_MaxDistance, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(NewProp_MaxDistance, TEXT("ToolTip"), TEXT("The maximum distance at which the actor can be activated by gaze. Set to 0 to ignore distance."));
				MetaData->SetValue(NewProp_MinDistance, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_MinDistance, TEXT("ModuleRelativePath"), TEXT("Public/EyeXActorBase.h"));
				MetaData->SetValue(NewProp_MinDistance, TEXT("ToolTip"), TEXT("The minimum distance at which the actor can be activated by gaze. Set to 0 to ignore distance."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AEyeXActorBase(Z_Construct_UClass_AEyeXActorBase, &AEyeXActorBase::StaticClass, TEXT("AEyeXActorBase"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AEyeXActorBase);
	UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEyeXEmulationMode"), 0, Get_Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EEyeXEmulationMode"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXEmulationMode::Disabled")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXEmulationMode::Enabled")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXEmulationMode::EEyeXEmulationMode_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EEyeXEmulationMode::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Disabled.DisplayName"), TEXT("Disabled"));
			MetaData->SetValue(ReturnEnum, TEXT("Enabled.DisplayName"), TEXT("Enabled"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Describes the available modes for mouse emulation of the gaze point."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode_CRC() { return 1967260250U; }
	UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEyeXUserPresence"), 0, Get_Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EEyeXUserPresence"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXUserPresence::Present")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXUserPresence::NotPresent")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXUserPresence::Unknown")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXUserPresence::EEyeXUserPresence_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EEyeXUserPresence::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("NotPresent.DisplayName"), TEXT("NotPresent"));
			MetaData->SetValue(ReturnEnum, TEXT("Present.DisplayName"), TEXT("Present"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Describes the possible user presence states."));
			MetaData->SetValue(ReturnEnum, TEXT("Unknown.DisplayName"), TEXT("Unknown"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence_CRC() { return 2129412266U; }
	UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEyeXDeviceStatus"), 0, Get_Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EEyeXDeviceStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDeviceStatus::Pending")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDeviceStatus::Tracking")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDeviceStatus::Disabled")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDeviceStatus::NotAvailable")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDeviceStatus::Unknown")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDeviceStatus::EEyeXDeviceStatus_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EEyeXDeviceStatus::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Disabled.DisplayName"), TEXT("Disabled"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("NotAvailable.DisplayName"), TEXT("NotAvailable"));
			MetaData->SetValue(ReturnEnum, TEXT("Pending.DisplayName"), TEXT("Pending"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Describes the possible device statuses."));
			MetaData->SetValue(ReturnEnum, TEXT("Tracking.DisplayName"), TEXT("Tracking"));
			MetaData->SetValue(ReturnEnum, TEXT("Unknown.DisplayName"), TEXT("Unknown"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus_CRC() { return 383479582U; }
	UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEyeXFixationDataMode"), 0, Get_Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EEyeXFixationDataMode"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXFixationDataMode::Sensitive")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXFixationDataMode::Slow")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXFixationDataMode::EEyeXFixationDataMode_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EEyeXFixationDataMode::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Sensitive.DisplayName"), TEXT("Sensitive"));
			MetaData->SetValue(ReturnEnum, TEXT("Slow.DisplayName"), TEXT("Slow"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Describes the available fixation data streams."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode_CRC() { return 2189444434U; }
	UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEyeXGazePointDataMode"), 0, Get_Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EEyeXGazePointDataMode"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXGazePointDataMode::Unfiltered")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXGazePointDataMode::LightlyFiltered")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXGazePointDataMode::EEyeXGazePointDataMode_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EEyeXGazePointDataMode::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("LightlyFiltered.DisplayName"), TEXT("LightlyFiltered"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Describes the available gaze data streams.\nUnfiltered: Unfiltered data from the eye tracker. The most responsive mode but can jitter a lot.\nLightlyFiltered: A light filtering applied by the EyeX Engine. Less jittering but also slightly less responsive."));
			MetaData->SetValue(ReturnEnum, TEXT("Unfiltered.DisplayName"), TEXT("Unfiltered"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode_CRC() { return 3044588680U; }
	UScriptStruct* Z_Construct_UScriptStruct_FEyeXScreenBounds()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UScriptStruct_FEyeXScreenBounds_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("EyeXScreenBounds"), sizeof(FEyeXScreenBounds), Get_Z_Construct_UScriptStruct_FEyeXScreenBounds_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EyeXScreenBounds"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FEyeXScreenBounds>, EStructFlags(0x00000001));
			UProperty* NewProp_Height = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Height"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Height, FEyeXScreenBounds), 0x0010000000000005);
			UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Width, FEyeXScreenBounds), 0x0010000000000005);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Y, FEyeXScreenBounds), 0x0010000000000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(X, FEyeXScreenBounds), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Holds the bounds of a screen in physical pixels."));
			MetaData->SetValue(NewProp_Height, TEXT("Category"), TEXT("EyeXScreenBounds"));
			MetaData->SetValue(NewProp_Height, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_Height, TEXT("ToolTip"), TEXT("Height of the screen in physical pixels."));
			MetaData->SetValue(NewProp_Width, TEXT("Category"), TEXT("EyeXScreenBounds"));
			MetaData->SetValue(NewProp_Width, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_Width, TEXT("ToolTip"), TEXT("Width of the screen in physical pixels."));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("EyeXScreenBounds"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_Y, TEXT("ToolTip"), TEXT("Y coordinate of the screen relative to the primary screen in physical pixels."));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("EyeXScreenBounds"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("ToolTip"), TEXT("X coordinate of the screen relative to the primary screen in physical pixels."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FEyeXScreenBounds_CRC() { return 3587104243U; }
	UScriptStruct* Z_Construct_UScriptStruct_FEyeXEyePosition()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UScriptStruct_FEyeXEyePosition_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("EyeXEyePosition"), sizeof(FEyeXEyePosition), Get_Z_Construct_UScriptStruct_FEyeXEyePosition_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EyeXEyePosition"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FEyeXEyePosition>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsRightEyeValid, FEyeXEyePosition, bool);
			UProperty* NewProp_bIsRightEyeValid = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsRightEyeValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsRightEyeValid, FEyeXEyePosition), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsRightEyeValid, FEyeXEyePosition), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLeftEyeValid, FEyeXEyePosition, bool);
			UProperty* NewProp_bIsLeftEyeValid = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLeftEyeValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLeftEyeValid, FEyeXEyePosition), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLeftEyeValid, FEyeXEyePosition), sizeof(bool), true);
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, FEyeXEyePosition), 0x0010000000000005);
			UProperty* NewProp_RightEye = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RightEye"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(RightEye, FEyeXEyePosition), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LeftEye = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeftEye"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeftEye, FEyeXEyePosition), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct to hold eye position data, including world position for both eyes in unreal coordinates\nand the coordinate system used by the EyeX engine, timestamp and validity status."));
			MetaData->SetValue(NewProp_bIsRightEyeValid, TEXT("Category"), TEXT("EyeXEyePosition"));
			MetaData->SetValue(NewProp_bIsRightEyeValid, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_bIsRightEyeValid, TEXT("ToolTip"), TEXT("If the right eye position is valid. Will be invalid if the tracker lost track of the right eye."));
			MetaData->SetValue(NewProp_bIsLeftEyeValid, TEXT("Category"), TEXT("EyeXEyePosition"));
			MetaData->SetValue(NewProp_bIsLeftEyeValid, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_bIsLeftEyeValid, TEXT("ToolTip"), TEXT("If the left eye position is valid. Will be invalid if the tracker lost track of the left eye."));
			MetaData->SetValue(NewProp_TimeStamp, TEXT("Category"), TEXT("EyeXEyePosition"));
			MetaData->SetValue(NewProp_TimeStamp, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_TimeStamp, TEXT("ToolTip"), TEXT("A timestamp of when the eye position was calculated in milliseconds."));
			MetaData->SetValue(NewProp_RightEye, TEXT("Category"), TEXT("EyeXEyePosition"));
			MetaData->SetValue(NewProp_RightEye, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_RightEye, TEXT("ToolTip"), TEXT("Position of the right eye in 3D-coordinates in relation to the screen."));
			MetaData->SetValue(NewProp_LeftEye, TEXT("Category"), TEXT("EyeXEyePosition"));
			MetaData->SetValue(NewProp_LeftEye, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_LeftEye, TEXT("ToolTip"), TEXT("Position of the left eye in 3D-coordinates in relation to the screen."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FEyeXEyePosition_CRC() { return 1707169139U; }
	UScriptStruct* Z_Construct_UScriptStruct_FEyeXFixationDataPoint()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UScriptStruct_FEyeXFixationDataPoint_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("EyeXFixationDataPoint"), sizeof(FEyeXFixationDataPoint), Get_Z_Construct_UScriptStruct_FEyeXFixationDataPoint_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EyeXFixationDataPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FEyeXFixationDataPoint>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, FEyeXFixationDataPoint, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, FEyeXFixationDataPoint), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bHasValue, FEyeXFixationDataPoint), sizeof(bool), true);
			UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Duration"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Duration, FEyeXFixationDataPoint), 0x0010000000000005);
			UProperty* NewProp_BeginTimeStamp = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BeginTimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BeginTimeStamp, FEyeXFixationDataPoint), 0x0010000000000005);
			UProperty* NewProp_GazePoint = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GazePoint, FEyeXFixationDataPoint), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct to hold fixation data."));
			MetaData->SetValue(NewProp_bHasValue, TEXT("Category"), TEXT("EyeXFixationDataPoint"));
			MetaData->SetValue(NewProp_bHasValue, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_bHasValue, TEXT("ToolTip"), TEXT("Value indicating whether this instance actually represents a data point."));
			MetaData->SetValue(NewProp_Duration, TEXT("Category"), TEXT("EyeXFixationDataPoint"));
			MetaData->SetValue(NewProp_Duration, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_Duration, TEXT("ToolTip"), TEXT("The duration of this fixation since it began."));
			MetaData->SetValue(NewProp_BeginTimeStamp, TEXT("Category"), TEXT("EyeXFixationDataPoint"));
			MetaData->SetValue(NewProp_BeginTimeStamp, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_BeginTimeStamp, TEXT("ToolTip"), TEXT("The timestamp of when this fixation began."));
			MetaData->SetValue(NewProp_GazePoint, TEXT("Category"), TEXT("EyeXFixationDataPoint"));
			MetaData->SetValue(NewProp_GazePoint, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_GazePoint, TEXT("ToolTip"), TEXT("The gaze point screen coordinate relative to the viewport."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FEyeXFixationDataPoint_CRC() { return 1594175866U; }
	UScriptStruct* Z_Construct_UScriptStruct_FEyeXGazePoint()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UScriptStruct_FEyeXGazePoint_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("EyeXGazePoint"), sizeof(FEyeXGazePoint), Get_Z_Construct_UScriptStruct_FEyeXGazePoint_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EyeXGazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FEyeXGazePoint>, EStructFlags(0x00000001));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, FEyeXGazePoint, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, FEyeXGazePoint), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bHasValue, FEyeXGazePoint), sizeof(bool), true);
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, FEyeXGazePoint), 0x0010000000000005);
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Value"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Value, FEyeXGazePoint), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Struct to hold gaze point data, including screen position, timestamp and validity status."));
			MetaData->SetValue(NewProp_bHasValue, TEXT("Category"), TEXT("EyeXGazePoint"));
			MetaData->SetValue(NewProp_bHasValue, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_bHasValue, TEXT("ToolTip"), TEXT("Value indicating whether this instance actually represents a data point."));
			MetaData->SetValue(NewProp_TimeStamp, TEXT("Category"), TEXT("EyeXGazePoint"));
			MetaData->SetValue(NewProp_TimeStamp, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_TimeStamp, TEXT("ToolTip"), TEXT("The timestamp of when this data was created by the EyeX Engine in milliseconds. Can vary\n      depending on the gaze point type."));
			MetaData->SetValue(NewProp_Value, TEXT("Category"), TEXT("EyeXGazePoint"));
			MetaData->SetValue(NewProp_Value, TEXT("ModuleRelativePath"), TEXT("Public/EyeXTypes.h"));
			MetaData->SetValue(NewProp_Value, TEXT("ToolTip"), TEXT("The gaze point screen coordinate relative to the viewport."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FEyeXGazePoint_CRC() { return 2844756538U; }
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_Get3DGazePoint()
	{
		struct EyeXBlueprintLibrary_eventGet3DGazePoint_Parms
		{
			TEnumAsByte<EEyeXGazePointDataMode::Type> Mode;
			FVector GazePoint;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Get3DGazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGet3DGazePoint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGet3DGazePoint_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGet3DGazePoint_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGet3DGazePoint_Parms), sizeof(bool), true);
			UProperty* NewProp_GazePoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GazePoint, EyeXBlueprintLibrary_eventGet3DGazePoint_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Mode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Mode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Mode, EyeXBlueprintLibrary_eventGet3DGazePoint_Parms), 0x0010000000000080, Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the latest eye-gaze data point of the specified mode in 3D space.\nThe origin of this coordinate system is in the center of the screen with the X-axis pointing\ninto the screen (in the direction away from the user), the Y-axis to the right and the\nZ-axis pointing upwards.\nThe data is in cm.\n\n@param Mode      - Specifies the kind of data processing to be applied by the EyeX Engine.\n@param GazePoint - the gaze point in 3D coordinates.\n@param bHasValue - Indicates whether the data point is valid."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetDisplaySize()
	{
		struct EyeXBlueprintLibrary_eventGetDisplaySize_Parms
		{
			FVector2D DisplaySize;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDisplaySize"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGetDisplaySize_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGetDisplaySize_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGetDisplaySize_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGetDisplaySize_Parms), sizeof(bool), true);
			UProperty* NewProp_DisplaySize = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DisplaySize"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DisplaySize, EyeXBlueprintLibrary_eventGetDisplaySize_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the physical size of the display where the eye tracker is mounted, in millimeters.\n\n@param DisplaySize - The physical size of the display.\n@param bHasValue   - Indicates whether the value is known."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEmulationMode()
	{
		struct EyeXBlueprintLibrary_eventGetEmulationMode_Parms
		{
			TEnumAsByte<EEyeXEmulationMode::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEmulationMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(EyeXBlueprintLibrary_eventGetEmulationMode_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, EyeXBlueprintLibrary_eventGetEmulationMode_Parms), 0x0010000000000580, Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the current emulation mode. The default is no emulation.\n\n@return The emulation mode."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyePosition()
	{
		struct EyeXBlueprintLibrary_eventGetEyePosition_Parms
		{
			FVector LeftEye;
			FVector RightEye;
			bool bIsLeftEyeValid;
			bool bIsRightEyeValid;
			float TimeStamp;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEyePosition"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGetEyePosition_Parms));
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, EyeXBlueprintLibrary_eventGetEyePosition_Parms), 0x0010000000000180);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsRightEyeValid, EyeXBlueprintLibrary_eventGetEyePosition_Parms, bool);
			UProperty* NewProp_bIsRightEyeValid = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsRightEyeValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsRightEyeValid, EyeXBlueprintLibrary_eventGetEyePosition_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bIsRightEyeValid, EyeXBlueprintLibrary_eventGetEyePosition_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLeftEyeValid, EyeXBlueprintLibrary_eventGetEyePosition_Parms, bool);
			UProperty* NewProp_bIsLeftEyeValid = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsLeftEyeValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLeftEyeValid, EyeXBlueprintLibrary_eventGetEyePosition_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bIsLeftEyeValid, EyeXBlueprintLibrary_eventGetEyePosition_Parms), sizeof(bool), true);
			UProperty* NewProp_RightEye = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("RightEye"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(RightEye, EyeXBlueprintLibrary_eventGetEyePosition_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LeftEye = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeftEye"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeftEye, EyeXBlueprintLibrary_eventGetEyePosition_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the latest eye position data in 3D space.\nThe origin of this coordinate system is in the center of the screen with the X-axis pointing\ninto the screen (in the direction away from the user), the Y-axis to the right and the\nZ-axis pointing upwards.\nThe data is in cm.\n\n@param LeftEye          - The coordinate of the left eye in cm.\n@param RightEye         - The coordinate of the right eye in cm.\n@param bIsLeftEyeValid  - True if the left eye position contains valid data. Will be false if\n                          the tracker failed to detect the left eye.\n@param bIsRightEyeValid - True if the right eye position contains valid data. Will be false\n                          if the tracker failed to detect the right eye.\n@param TimeStamp        - The time this data was created in milliseconds."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyeTrackingDeviceStatus()
	{
		struct EyeXBlueprintLibrary_eventGetEyeTrackingDeviceStatus_Parms
		{
			TEnumAsByte<EEyeXDeviceStatus::Type> DeviceStatus;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEyeTrackingDeviceStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(EyeXBlueprintLibrary_eventGetEyeTrackingDeviceStatus_Parms));
			UProperty* NewProp_DeviceStatus = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeviceStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DeviceStatus, EyeXBlueprintLibrary_eventGetEyeTrackingDeviceStatus_Parms), 0x0010000000000180, Z_Construct_UEnum_TobiiEyeX_EEyeXDeviceStatus());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the status of the eye tracking device.\n\n@param DeviceStatus - The device status."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetGazePoint()
	{
		struct EyeXBlueprintLibrary_eventGetGazePoint_Parms
		{
			TEnumAsByte<EEyeXGazePointDataMode::Type> Mode;
			FVector2D GazePoint;
			float Timestamp;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGetGazePoint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGetGazePoint_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGetGazePoint_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGetGazePoint_Parms), sizeof(bool), true);
			UProperty* NewProp_Timestamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Timestamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Timestamp, EyeXBlueprintLibrary_eventGetGazePoint_Parms), 0x0010000000000180);
			UProperty* NewProp_GazePoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GazePoint, EyeXBlueprintLibrary_eventGetGazePoint_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_Mode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Mode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Mode, EyeXBlueprintLibrary_eventGetGazePoint_Parms), 0x0010000000000080, Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the latest eye-gaze data point of the specified mode.\n\n@param Mode      - Specifies the kind of data processing to be applied by the EyeX Engine.\n                   Unfiltered: Unfiltered data from the eye tracker. The most responsive mode,\n                   but can jitter a lot.\n                   LightlyFiltered: A light filtering applied by the EyeX Engine. Less\n                   jittering but also slightly less responsive.\n@param GazePoint - The gaze point in viewport coordinates (pixels).\n@param TimeStamp - The time this data was created in milliseconds.\n@param bHasValue - Indicates whether the data point is valid."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetHeadRotation()
	{
		struct EyeXBlueprintLibrary_eventGetHeadRotation_Parms
		{
			FRotator Rotation;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHeadRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGetHeadRotation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGetHeadRotation_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGetHeadRotation_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGetHeadRotation_Parms), sizeof(bool), true);
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Rotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Rotation, EyeXBlueprintLibrary_eventGetHeadRotation_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the rotation of the users head. Note that pitch cannot be calculated using the eye\ntracker and is always zero. Both eyes need to be tracked in order to calculate head rotation.\n\n@param Rotation  - The rotation of the user's head.\n@param bHasValue - Indicates whether the data point is valid."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetLastFixation()
	{
		struct EyeXBlueprintLibrary_eventGetLastFixation_Parms
		{
			TEnumAsByte<EEyeXFixationDataMode::Type> Mode;
			FVector2D GazePoint;
			float BeginTimeStamp;
			float Duration;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetLastFixation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGetLastFixation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGetLastFixation_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGetLastFixation_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGetLastFixation_Parms), sizeof(bool), true);
			UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Duration"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Duration, EyeXBlueprintLibrary_eventGetLastFixation_Parms), 0x0010000000000180);
			UProperty* NewProp_BeginTimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BeginTimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BeginTimeStamp, EyeXBlueprintLibrary_eventGetLastFixation_Parms), 0x0010000000000180);
			UProperty* NewProp_GazePoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GazePoint, EyeXBlueprintLibrary_eventGetLastFixation_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_Mode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Mode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Mode, EyeXBlueprintLibrary_eventGetLastFixation_Parms), 0x0010000000000080, Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the last complete fixation.\nAs soon as an ongoing fixation is complete it will be saved as the last fixation. While a new\nfixation is ongoing, the last fixation will not be changed.\nThe unique BeginTimeStamp property can be used to compare if fixations are different from\none another.\n\n@param Mode           - Specifies the kind of data processing to be applied by the EyeX Engine.\n@param GazePoint      - The gaze point in viewport coordinates (pixels).\n@param BeginTimeStamp - The time the fixation started in milliseconds.\n@param Duration       - The total duration of this fixation in milliseconds.\n@param bHasValue      - Indicates whether the data point is valid."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetOngoingFixation()
	{
		struct EyeXBlueprintLibrary_eventGetOngoingFixation_Parms
		{
			TEnumAsByte<EEyeXFixationDataMode::Type> Mode;
			FVector2D GazePoint;
			float BeginTimeStamp;
			float Duration;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOngoingFixation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(EyeXBlueprintLibrary_eventGetOngoingFixation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms), sizeof(bool), true);
			UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Duration"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Duration, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms), 0x0010000000000180);
			UProperty* NewProp_BeginTimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BeginTimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(BeginTimeStamp, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms), 0x0010000000000180);
			UProperty* NewProp_GazePoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GazePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GazePoint, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_Mode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Mode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Mode, EyeXBlueprintLibrary_eventGetOngoingFixation_Parms), 0x0010000000000080, Z_Construct_UEnum_TobiiEyeX_EEyeXFixationDataMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the latest fixation data for the ongoing fixation.\nWhen a fixation is ongoing, the only changing properties are the gaze point and the duration.\nThe gaze point converges towards the most likely point the eyes are lingering at, and the\nduration increases until the fixation reaches the fixation is complete. When the ongoing\nfixation is complete, it is set as the last fixation (retrievable with GetLastFixation), and\nthe ongoing fixation is set to an invalid value until a new fixation has started.\n\n@param Mode           - Specifies the kind of data processing to be applied by the EyeX Engine.\n@param GazePoint      - The gaze point in viewport coordinates (pixels).\n@param BeginTimeStamp - The time the fixation started in milliseconds.\n@param Duration       - The duration of this ongoing fixation since it began, in milliseconds.\n@param bHasValue      - Indicates whether the data point is valid."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetScreenBounds()
	{
		struct EyeXBlueprintLibrary_eventGetScreenBounds_Parms
		{
			int32 X;
			int32 Y;
			int32 Width;
			int32 Height;
			bool bHasValue;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetScreenBounds"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(EyeXBlueprintLibrary_eventGetScreenBounds_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasValue, EyeXBlueprintLibrary_eventGetScreenBounds_Parms, bool);
			UProperty* NewProp_bHasValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHasValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasValue, EyeXBlueprintLibrary_eventGetScreenBounds_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHasValue, EyeXBlueprintLibrary_eventGetScreenBounds_Parms), sizeof(bool), true);
			UProperty* NewProp_Height = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Height"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Height, EyeXBlueprintLibrary_eventGetScreenBounds_Parms), 0x0010000000000180);
			UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Width, EyeXBlueprintLibrary_eventGetScreenBounds_Parms), 0x0010000000000180);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Y, EyeXBlueprintLibrary_eventGetScreenBounds_Parms), 0x0010000000000180);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(X, EyeXBlueprintLibrary_eventGetScreenBounds_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the bounds of the screen where the eye tracker is mounted, in physical pixels.\n\n@param X         - The X coordinate of the screen in physical pixels. The primary screen will have X = 0 and Y = 0.\n@param Y         - The Y coordinate of the screen in physical pixels.\n@param Width     - The width of the screen in physical pixels.\n@param Height    - The height of the screen in physical pixels.\n@param bHasValue - Indicates whether the value is known."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_GetUserPresence()
	{
		struct EyeXBlueprintLibrary_eventGetUserPresence_Parms
		{
			TEnumAsByte<EEyeXUserPresence::Type> UserPresence;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetUserPresence"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(EyeXBlueprintLibrary_eventGetUserPresence_Parms));
			UProperty* NewProp_UserPresence = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UserPresence"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(UserPresence, EyeXBlueprintLibrary_eventGetUserPresence_Parms), 0x0010000000000180, Z_Construct_UEnum_TobiiEyeX_EEyeXUserPresence());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the user presence (that is, whether the eye tracker can detect the user's eyes).\n\n@param UserPresence - The user presence status."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UEyeXBlueprintLibrary_SetEmulationMode()
	{
		struct EyeXBlueprintLibrary_eventSetEmulationMode_Parms
		{
			TEnumAsByte<EEyeXEmulationMode::Type> Mode;
		};
		UObject* Outer=Z_Construct_UClass_UEyeXBlueprintLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEmulationMode"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(EyeXBlueprintLibrary_eventSetEmulationMode_Parms));
			UProperty* NewProp_Mode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Mode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Mode, EyeXBlueprintLibrary_eventSetEmulationMode_Parms), 0x0010000000000080, Z_Construct_UEnum_TobiiEyeX_EEyeXEmulationMode());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the emulation mode for the eye-gaze point. The default is no emulation.\n\n@param Mode - The emulation mode."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UEyeXBlueprintLibrary_NoRegister()
	{
		return UEyeXBlueprintLibrary::StaticClass();
	}
	UClass* Z_Construct_UClass_UEyeXBlueprintLibrary()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UBlueprintFunctionLibrary();
			Z_Construct_UPackage__Script_TobiiEyeX();
			OuterClass = UEyeXBlueprintLibrary::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;

				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_Get3DGazePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetDisplaySize());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEmulationMode());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyePosition());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyeTrackingDeviceStatus());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetGazePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetHeadRotation());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetLastFixation());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetOngoingFixation());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetScreenBounds());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetUserPresence());
				OuterClass->LinkChild(Z_Construct_UFunction_UEyeXBlueprintLibrary_SetEmulationMode());

				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_Get3DGazePoint(), "Get3DGazePoint"); // 1625197309
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetDisplaySize(), "GetDisplaySize"); // 3939647900
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEmulationMode(), "GetEmulationMode"); // 2134538255
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyePosition(), "GetEyePosition"); // 1244105419
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetEyeTrackingDeviceStatus(), "GetEyeTrackingDeviceStatus"); // 933789633
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetGazePoint(), "GetGazePoint"); // 2413398139
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetHeadRotation(), "GetHeadRotation"); // 2747403550
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetLastFixation(), "GetLastFixation"); // 3556529351
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetOngoingFixation(), "GetOngoingFixation"); // 1546946142
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetScreenBounds(), "GetScreenBounds"); // 3842311418
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_GetUserPresence(), "GetUserPresence"); // 3958478567
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UEyeXBlueprintLibrary_SetEmulationMode(), "SetEmulationMode"); // 1594772089
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("EyeXBlueprintLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Private/EyeXBlueprintLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A blueprint library class to expose the functionality of the EyeX plugin to blueprints\nin all blueprint contexts."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UEyeXBlueprintLibrary(Z_Construct_UClass_UEyeXBlueprintLibrary, &UEyeXBlueprintLibrary::StaticClass, TEXT("UEyeXBlueprintLibrary"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UEyeXBlueprintLibrary);
	UEnum* Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_TobiiEyeX();
		extern uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EEyeXDetectionMode"), 0, Get_Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EEyeXDetectionMode"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDetectionMode::None")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDetectionMode::LineTrace")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDetectionMode::BoxedLineTrace")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDetectionMode::Sweep")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDetectionMode::FrustrumIntersection")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EEyeXDetectionMode::EEyeXDetectionMode_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EEyeXDetectionMode::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("BoxedLineTrace.DisplayName"), TEXT("BoxedLineTrace"));
			MetaData->SetValue(ReturnEnum, TEXT("FrustrumIntersection.DisplayName"), TEXT("FrustrumIntersection"));
			MetaData->SetValue(ReturnEnum, TEXT("LineTrace.DisplayName"), TEXT("LineTrace"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
			MetaData->SetValue(ReturnEnum, TEXT("None.DisplayName"), TEXT("None"));
			MetaData->SetValue(ReturnEnum, TEXT("Sweep.DisplayName"), TEXT("Sweep"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Describes the available strategies for detecting actors being looked at.\nYou may want to use different strategies in different scenes based on factors such as actor\ngeometry and how crowded the scene is.\nThere are also performance trade-offs to be made.\n\nNone: Actor detection is disabled.\nLineTrace: Performs a line trace to find a focused actor. Fast, but actors may need to be\n  surrounded in volumes, otherwise the gaze point will often miss the object.\nBoxedLineTrace: Starts with a basic line trace. If no actors are found, does additional line\n  traces in a box shape around the gaze point.\nSweep: Performs multiple sweeps, trying to keep the size of the swept sphere to a fixed size in\n  mm. Has an easier time hitting the object the user is looking at but is more expensive.\nFrustrumIntersection: Calculates a view frustrum defined by GazeBoxExtents (a box in screen\n  space) and checks for intersection with the frustum. Should be pretty accurate but can be slow\n  if the scene contains many EyeXActors with a lot of vertices. Since Frustum Intersection only\n  checks EyeXActorBases it can't be used to get a Hit from other actor types."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode_CRC() { return 2585004170U; }
	UFunction* Z_Construct_UFunction_AEyeXPlayerController_GetGazeHitResult()
	{
		struct EyeXPlayerController_eventGetGazeHitResult_Parms
		{
			FVector ImpactPoint;
			AActor* HitActor;
			bool bIsValid;
		};
		UObject* Outer=Z_Construct_UClass_AEyeXPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGazeHitResult"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54C20401, 65535, sizeof(EyeXPlayerController_eventGetGazeHitResult_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsValid, EyeXPlayerController_eventGetGazeHitResult_Parms, bool);
			UProperty* NewProp_bIsValid = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsValid, EyeXPlayerController_eventGetGazeHitResult_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bIsValid, EyeXPlayerController_eventGetGazeHitResult_Parms), sizeof(bool), true);
			UProperty* NewProp_HitActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HitActor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(HitActor, EyeXPlayerController_eventGetGazeHitResult_Parms), 0x0010000000000180, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_ImpactPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ImpactPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ImpactPoint, EyeXPlayerController_eventGetGazeHitResult_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("EyeX"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the Impact Point, Hit Actor and validity of the HitResult of the latest sweep from the gaze point.\nWhen using Focal Intersection as detection mode the result will not be as accurate."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AEyeXPlayerController_NoRegister()
	{
		return AEyeXPlayerController::StaticClass();
	}
	UClass* Z_Construct_UClass_AEyeXPlayerController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APlayerController();
			Z_Construct_UPackage__Script_TobiiEyeX();
			OuterClass = AEyeXPlayerController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900284;

				OuterClass->LinkChild(Z_Construct_UFunction_AEyeXPlayerController_GetGazeHitResult());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BoxSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoxSize"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(BoxSize, AEyeXPlayerController), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
				UProperty* NewProp_SweepIntervals = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SweepIntervals"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(SweepIntervals, AEyeXPlayerController), 0x0010000000000005);
				UProperty* NewProp_SweepSphereRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SweepSphereRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SweepSphereRadius, AEyeXPlayerController), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVisualizeDetection, AEyeXPlayerController, bool);
				UProperty* NewProp_bVisualizeDetection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bVisualizeDetection"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVisualizeDetection, AEyeXPlayerController), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bVisualizeDetection, AEyeXPlayerController), sizeof(bool), true);
				UProperty* NewProp_MinUpdateDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MinUpdateDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MinUpdateDistance, AEyeXPlayerController), 0x0010000000000005);
				UProperty* NewProp_CollisionChannels = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CollisionChannels"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(CollisionChannels, AEyeXPlayerController), 0x0010000000000005);
				UProperty* NewProp_CollisionChannels_Inner = new(EC_InternalUseOnlyConstructor, NewProp_CollisionChannels, TEXT("CollisionChannels"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UEnum_Engine_ECollisionChannel());
				UProperty* NewProp_MaxDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxDistance, AEyeXPlayerController), 0x0010000000000005);
				UProperty* NewProp_GazePointMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GazePointMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GazePointMode, AEyeXPlayerController), 0x0010000000000005, Z_Construct_UEnum_TobiiEyeX_EEyeXGazePointDataMode());
				UProperty* NewProp_DetectionMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DetectionMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DetectionMode, AEyeXPlayerController), 0x0010000000000005, Z_Construct_UEnum_TobiiEyeX_EEyeXDetectionMode());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AEyeXPlayerController_GetGazeHitResult(), "GetGazeHitResult"); // 2412884679
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("EyeXPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The EyeX player controller is used to enable interaction with actors derived from AEyeXActorBase.\nIf you only want to use gaze data or eye position data, etc., you can ignore this class.\n\nThere are several strategies for detecting actors being looked at:\n\nThe simplest is Line Trace which simply shoots a ray from the gaze point. This is fast\nbut actors should be surrounded with collision volumes in order to get better interaction.\n\nWhen using Sweep mode the size of the sphere is calculated to fit a given dimension\nin millimeters, effectively triggering objects in an area around the gaze point. This enables\nbetter interaction since the gaze point often times contain noise or offsets.\nThis can however be expensive performance wise so if there are a lot of objects\nin the scene a simple line trace might be better.\n\nFrustum Intersection calculates a frustum from a box in screen space given in millimeters and\nchecks for intersection with actors. This can give good interaction but can be costly with\nmany actors in the scene, especially if these actors have many vertices."));
				MetaData->SetValue(NewProp_BoxSize, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_BoxSize, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_BoxSize, TEXT("ToolTip"), TEXT("Used when DetectionMode is set to BoxedLineTrace or FrustrumIntersection.\n      Determines how large the box around the gaze point is in mm. This box is used to calculate the frustum."));
				MetaData->SetValue(NewProp_SweepIntervals, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_SweepIntervals, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_SweepIntervals, TEXT("ToolTip"), TEXT("Used when Detection Mode is set to Sweep. The number of intervals that the distance is split into. At each new interval the size of\n      the sphere is recalculated to try to keep the sphere at the same size on the screen. A higher value\n      will lead to a more constant gaze area size but may be costly performance wise."));
				MetaData->SetValue(NewProp_SweepSphereRadius, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_SweepSphereRadius, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_SweepSphereRadius, TEXT("ToolTip"), TEXT("Used when Detection Mode is set to Sweep. The radius of the sphere used to perform sweeps. The value is given in real world mm's. The\n      sweep system tries to keep the size of the sphere constant on the screen regardless of distance."));
				MetaData->SetValue(NewProp_bVisualizeDetection, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_bVisualizeDetection, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_bVisualizeDetection, TEXT("ToolTip"), TEXT("Set to true to visualize the detection process. Disabled for shipping builds."));
				MetaData->SetValue(NewProp_MinUpdateDistance, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_MinUpdateDistance, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_MinUpdateDistance, TEXT("ToolTip"), TEXT("The minimum distance in mm the latest gaze point has to differ from the previous\n      gaze point in order to perform a new detection. Set to 0 to always perform a detection."));
				MetaData->SetValue(NewProp_CollisionChannels, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_CollisionChannels, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_CollisionChannels, TEXT("ToolTip"), TEXT("Determines which channels to perform the detection on."));
				MetaData->SetValue(NewProp_MaxDistance, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_MaxDistance, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_MaxDistance, TEXT("ToolTip"), TEXT("The maximum distance from the camera that an object can be detected. Lower values can increase performance."));
				MetaData->SetValue(NewProp_GazePointMode, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_GazePointMode, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_GazePointMode, TEXT("ToolTip"), TEXT("Choice of data mode for gaze interaction. The default is LightlyFiltered.\nUnfiltered: Unfiltered data from the eye tracker. The most responsive mode but can jitter a lot.\nLightlyFiltered: A light filtering applied by the EyeX Engine. Less jittering but also slightly less responsive."));
				MetaData->SetValue(NewProp_DetectionMode, TEXT("Category"), TEXT("EyeX"));
				MetaData->SetValue(NewProp_DetectionMode, TEXT("ModuleRelativePath"), TEXT("Public/EyeXPlayerController.h"));
				MetaData->SetValue(NewProp_DetectionMode, TEXT("ToolTip"), TEXT("Choice of method for detecting gaze actors being looked at. The default is LineTrace.\nNone: Actor detection is disabled.\nLineTrace: Performs a simple line trace to find a focused actor. Fast, but actors may need to be\n  surrounded in volumes, otherwise the gaze point will often miss the object.\nBoxedLineTrace: Starts with a basic line trace. If no actors are found, does additional line\n  traces in a box shape around the gaze point.\nSweep: Performs multiple sweeps, trying to keep the size of the swept sphere to a fixed size in\n  mm. Has an easier time hitting the object the user is looking at but is more expensive.\nFrustrumIntersection: Calculates a view frustrum defined by GazeBoxExtents (a box in screen\n  space) and checks for intersection with the frustum. Should be pretty accurate but can be slow\n  if the scene contains many EyeXActors with a lot of vertices. Since Frustum Intersection only\n  checks EyeXActorBases it can't be used to get a Hit from other actor types."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AEyeXPlayerController(Z_Construct_UClass_AEyeXPlayerController, &AEyeXPlayerController::StaticClass, TEXT("AEyeXPlayerController"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AEyeXPlayerController);
	UPackage* Z_Construct_UPackage__Script_TobiiEyeX()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/TobiiEyeX")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x472885BE;
			Guid.B = 0xC9BB20CB;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
